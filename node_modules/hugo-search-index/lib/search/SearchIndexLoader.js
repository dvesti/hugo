exports.__esModule = true;
var pako = require("pako");
var stream_1 = require("stream");
/**
 * Converts an array buffer to a string
 *
 * @param {Uin8} uint8arr | The buffer to convert
 * @param {Function} callback | The function to call when conversion is complete
 */
function largeuint8ArrToString(uint8arr, callback) {
    var bb = new Blob([uint8arr]);
    var f = new FileReader();
    f.onload = function (e) {
        callback(e.target.result);
    };
    f.readAsText(bb);
}
function inflate(contents, cb) {
    try {
        var inflated = pako.inflate(contents, { to: 'string' });
        cb(null, inflated);
    }
    catch (err) {
        if (err !== 'incorrect header check') {
            cb(err);
            return;
        }
        // the browser already inflated this for us.
        // This happens if the server supports gzip encoding,
        // and sets the 'Content-Encoding: "gzip"' header.
        largeuint8ArrToString(contents, function (result) {
            cb(null, result);
        });
    }
}
var SearchIndexLoader = (function () {
    function SearchIndexLoader(lib, options) {
        this.lib = lib || SearchIndex;
        this.options = options || {
            keySeparator: '~'
        };
    }
    SearchIndexLoader.prototype.load = function (contents, cb) {
        var _this = this;
        inflate(contents, function (inflateErr, inflated) {
            if (inflateErr) {
                cb(inflateErr);
                return;
            }
            var options = _this.options;
            _this.lib(_this.options, function (libErr, si) {
                if (libErr) {
                    cb(libErr);
                    return;
                }
                var i = 0;
                var lines = 0;
                var docStream = new stream_1.Readable({
                    objectMode: true,
                    read: function () {
                        var chunk;
                        do {
                            if (i >= inflated.length) {
                                this.push(null);
                                return;
                            }
                            var nextNewline = inflated.indexOf('\n', i);
                            if (nextNewline <= i) {
                                nextNewline = undefined;
                            }
                            var substr = inflated.substring(i, nextNewline);
                            chunk = JSON.parse(substr);
                            if (nextNewline) {
                                i = nextNewline + 1;
                            }
                            else {
                                i = inflated.length;
                            }
                            lines++;
                            // console.log(lines + ': ', chunk)
                        } while (this.push(chunk));
                    }
                });
                docStream
                    .pipe(si.dbWriteStream({ merge: false }))
                    .on('data', function () { })
                    .on('finish', function () {
                    cb(null, si);
                })
                    .on('error', function (error) {
                    cb(error);
                });
            });
        });
    };
    return SearchIndexLoader;
}());
exports.SearchIndexLoader = SearchIndexLoader;
exports["default"] = SearchIndexLoader;
